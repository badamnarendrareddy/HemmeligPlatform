import nacl from 'tweetnacl';

// Encrypt data  XSalsa20
export const encryptData = (data, key) => {
  const nonce = nacl.randomBytes(nacl.secretbox.nonceLength);
  const encodedData = new TextEncoder().encode(data);
  const encrypted = nacl.secretbox(encodedData, nonce, key);

  // Convert Uint8Array to Base64
  const encryptedBase64 = btoa(String.fromCharCode(...encrypted));
  const nonceBase64 = btoa(String.fromCharCode(...nonce));

  return { nonce: nonceBase64, encrypted: encryptedBase64 };
};

// Decrypt data
export const decryptData = (encryptedBase64, nonceBase64, key) => {
  // Convert Base64 back to Uint8Array
  const encrypted = new Uint8Array(
    atob(encryptedBase64)
      .split('')
      .map((char) => char.charCodeAt(0))
  );
  const nonce = new Uint8Array(
    atob(nonceBase64)
      .split('')
      .map((char) => char.charCodeAt(0))
  );

  const decrypted = nacl.secretbox.open(encrypted, nonce, key);
  if (!decrypted) throw new Error("Decryption failed");
  return new TextDecoder().decode(decrypted);
};

//  stream cipher algorithm designed by Daniel J. Bernstein in 2008. It's an extension of the Salsa20 algorithm, which is a widely used and respected cryptographic primitive.

/*Features of XSalsa20
1. Stream Cipher: XSalsa20 is a stream cipher, meaning it encrypts data in a continuous stream, rather than in fixed-size blocks.
2. Fast and Efficient: XSalsa20 is designed to be fast and efficient, making it suitable for high-speed encryption applications.
3. High Security: XSalsa20 is considered to be highly secure, with a large key size (256 bits) and a robust design that resists various types of attacks.
4. Nonce-based: XSalsa20 uses a nonce (number used once) to ensure that each encrypted message is unique, even if the same key is used.

How XSalsa20 Works
1. Key and Nonce: The algorithm takes a 256-bit key and a 64-bit nonce as input.
2. Hash Function: XSalsa20 uses a hash function (HSalsa20) to generate a keystream from the key and nonce.
3. Keystream Generation: The keystream is generated by iterating the hash function with the key and nonce.
4. Encryption: The plaintext data is encrypted by XORing it with the keystream. */